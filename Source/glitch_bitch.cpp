/*
 ==============================================================================

 This file was auto-generated by the Introjucer!

 It contains the basic framework code for a JUCE plugin processor.

 ==============================================================================
 */

#include "glitch_bitch.h"
#include "glitch_bitch_editor.h"


//==============================================================================
GlitchBitch::GlitchBitch() : volume(0.0), phase(0.0) { }

GlitchBitch::~GlitchBitch() { }

//==============================================================================
const String GlitchBitch::getName() const {
  return JucePlugin_Name;
}

int GlitchBitch::getNumParameters() {
  return 0;
}

float GlitchBitch::getParameter(int index) {
  return 0.0f;
}

void GlitchBitch::setParameter(int index, float new_value) {
}

const String GlitchBitch::getParameterName(int index) {
  return String();
}

const String GlitchBitch::getParameterText(int index) {
  return String();
}

const String GlitchBitch::getInputChannelName(int channel_index) const {
  return String (channel_index + 1);
}

const String GlitchBitch::getOutputChannelName(int channel_index) const {
  return String (channel_index + 1);
}

bool GlitchBitch::isInputChannelStereoPair(int index) const {
  return true;
}

bool GlitchBitch::isOutputChannelStereoPair(int index) const {
  return true;
}

bool GlitchBitch::acceptsMidi() const {
#if JucePlugin_WantsMidiInput
  return true;
#else
  return false;
#endif
}

bool GlitchBitch::producesMidi() const {
#if JucePlugin_ProducesMidiOutput
  return true;
#else
  return false;
#endif
}

bool GlitchBitch::silenceInProducesSilenceOut() const {
  return false;
}

double GlitchBitch::getTailLengthSeconds() const {
  return 0.0;
}

int GlitchBitch::getNumPrograms() {
  return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
  // so this should be at least 1, even if you're not really implementing programs.
}

int GlitchBitch::getCurrentProgram() {
  return 0;
}

void GlitchBitch::setCurrentProgram(int index) {
}

const String GlitchBitch::getProgramName(int index) {
  return String();
}

void GlitchBitch::changeProgramName(int index, const String& new_name) {
}

//==============================================================================
void GlitchBitch::prepareToPlay(double sample_rate, int buffer_size) {
  synth_.setSampleRate(sample_rate);
  synth_.setBufferSize(buffer_size);
}

void GlitchBitch::releaseResources() {
  // When playback stops, you can use this as an opportunity to free up any
  // spare memory, etc.
}

void GlitchBitch::processBlock(AudioSampleBuffer& buffer, MidiBuffer& midi_messages) {
  MidiBuffer::Iterator midi_iter(midi_messages);
  MidiMessage midi_message;
  int midi_sample_position = 0;
  while (midi_iter.getNextEvent(midi_message, midi_sample_position)) {
    if (midi_message.isNoteOn()) {
      float velocity = (1.0 * midi_message.getVelocity()) / mopo::MIDI_SIZE;
      synth_.noteOn(midi_message.getNoteNumber(), velocity);
    }
    else if (midi_message.isNoteOff())
      synth_.noteOff(midi_message.getNoteNumber());
  }

  int num_samples = buffer.getNumSamples();
  int num_channels = getNumOutputChannels();

  synth_.setBufferSize(num_samples);
  synth_.process();

  const mopo::mopo_float* synth_output = synth_.output()->buffer;
  for (int channel = 0; channel < num_channels; ++channel) {
    float* channelData = buffer.getWritePointer(channel);

    for (int i = 0; i < num_samples; ++i)
      channelData[i] = synth_output[i];
  }
}

//==============================================================================
bool GlitchBitch::hasEditor() const {
  return true;
}

AudioProcessorEditor* GlitchBitch::createEditor() {
  return new GlitchBitchEditor(*this);
}

//==============================================================================
void GlitchBitch::getStateInformation(MemoryBlock& dest_data) {
  // You should use this method to store your parameters in the memory block.
  // You could do that either as raw data, or use the XML or ValueTree classes
  // as intermediaries to make it easy to save and load complex data.
}

void GlitchBitch::setStateInformation(const void* data, int size_in_bytes) {
  // You should use this method to restore your parameters from this memory block,
  // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter() {
  return new GlitchBitch();
}
